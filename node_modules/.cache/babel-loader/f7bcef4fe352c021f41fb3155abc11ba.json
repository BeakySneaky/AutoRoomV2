{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Alexandre\\\\Documents\\\\HomeProjects\\\\AutoRoomV2\\\\src\\\\App.js\";\nimport React from 'react';\nimport SnackBar from './SnackBar';\nimport './App.css';\nimport { w3cwebsocket as WebSocket } from 'websocket';\nexport default class App extends React.Component {\n  constructor() {\n    super();\n\n    this.connect = () => {\n      var ws = new WebSocket('ws://127.0.0.1:3002');\n      let that = this;\n      var connectInterval; // websocket onopen event listener\n\n      ws.onopen = () => {\n        console.log('Connected Websocket to Server');\n        this.setState({\n          ServerStatusText: \"SERVER ONLINE\"\n        });\n        this.setState({\n          WakeOnLanAvailable: true\n        });\n        this.setState({\n          ws: ws\n        });\n        that.timeout = 250;\n        clearTimeout(connectInterval);\n      };\n\n      ws.onmessage = evt => {\n        // listen to data sent from the websocket server\n        const message = evt.data;\n\n        if (message === \"WOL_Success\") {\n          this.sendSnackBar('WOL request sent !');\n        }\n\n        console.log(message);\n      }; // websocket onclose event listener\n\n\n      ws.onclose = e => {\n        this.setState({\n          ServerStatusText: \"SERVER OFFLINE\"\n        });\n        this.setState({\n          WakeOnLanAvailable: false\n        });\n        console.log(`Socket is closed. Attempt to reconnect in ${Math.min(10000 / 1000, (that.timeout + that.timeout) / 1000)} second.`, e.reason);\n        that.timeout = that.timeout + that.timeout; //increment retry interval\n\n        connectInterval = setTimeout(this.check, Math.min(10000, that.timeout)); //call check function after timeout\n      }; // websocket onerror event listener\n\n\n      ws.onerror = err => {\n        console.error('Socket encountered error: ', err.message, 'Closing socket');\n        ws.close();\n      };\n    };\n\n    this.check = () => {\n      const {\n        ws\n      } = this.state;\n      if (!ws || ws.readyState === WebSocket.CLOSED) this.connect(); //check if websocket instance is closed, if so call `connect` function.\n    };\n\n    this.wol = () => {\n      const {\n        ws\n      } = this.state;\n      ws.send('WOL'); //this.sendSnackBar('WOL request sent !')\n    };\n\n    this.sendSnackBar = message => {\n      setTimeout(() => {\n        this.setState({\n          SnackBarOn: false\n        });\n      }, 3000);\n      this.setState({\n        SnackBarOn: true,\n        SnackBarText: message\n      });\n    };\n\n    this.state = {\n      SnackBarOn: false,\n      SnackBarText: null,\n      ServerStatusText: null,\n      WakeOnLanAvailable: false,\n      Ws: null\n    };\n  }\n\n  componentDidMount() {\n    this.connect();\n  }\n\n  render() {\n    if (this.state.WakeOnLanAvailable === true) {\n      return React.createElement(\"div\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 91\n        },\n        __self: this\n      }, React.createElement(\"h1\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 92\n        },\n        __self: this\n      }, this.state.ServerStatusText), React.createElement(\"button\", {\n        onClick: this.wol,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 93\n        },\n        __self: this\n      }, \"Wake On Lan\"), this.state.SnackBarOn === true ? React.createElement(SnackBar, {\n        text: this.state.SnackBarText,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 95\n        },\n        __self: this\n      }) : '');\n    } else {\n      return null;\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Alexandre/Documents/HomeProjects/AutoRoomV2/src/App.js"],"names":["React","SnackBar","w3cwebsocket","WebSocket","App","Component","constructor","connect","ws","that","connectInterval","onopen","console","log","setState","ServerStatusText","WakeOnLanAvailable","timeout","clearTimeout","onmessage","evt","message","data","sendSnackBar","onclose","e","Math","min","reason","setTimeout","check","onerror","err","error","close","state","readyState","CLOSED","wol","send","SnackBarOn","SnackBarText","Ws","componentDidMount","render"],"mappings":"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","sourcesContent":["import React from 'react'\nimport SnackBar from './SnackBar'\nimport './App.css'\nimport { w3cwebsocket as WebSocket } from 'websocket'\n\nexport default class App extends React.Component {\n\tconstructor() {\n\t\tsuper()\n\t\tthis.state = {\n\t\t\tSnackBarOn: false,\n\t\t\tSnackBarText: null,\n\t\t\tServerStatusText: null,\n\t\t\tWakeOnLanAvailable: false,\n\t\t\tWs: null,\n\t\t}\n\t}\n\n\tcomponentDidMount() {\n\t\tthis.connect()\n\t}\n\n\tconnect = () => {\n\t\tvar ws = new WebSocket('ws://127.0.0.1:3002')\n\t\tlet that = this\n\t\tvar connectInterval\n\n\t\t// websocket onopen event listener\n\t\tws.onopen = () => {\n\t\t\tconsole.log('Connected Websocket to Server')\n\t\t\tthis.setState({ServerStatusText: \"SERVER ONLINE\"})\n\t\t\tthis.setState({ WakeOnLanAvailable: true })\n\t\t\tthis.setState({ ws: ws })\n\n\t\t\tthat.timeout = 250\n\t\t\tclearTimeout(connectInterval)\n\t\t}\n\t\tws.onmessage = (evt) => {\n\t\t\t// listen to data sent from the websocket server\n\t\t\tconst message = evt.data\n\t\t\tif(message === \"WOL_Success\"){\n\t\t\t\tthis.sendSnackBar('WOL request sent !')\n\t\t\t}\n\t\t\tconsole.log(message)\n\t\t}\n\n\t\t// websocket onclose event listener\n\t\tws.onclose = (e) => {\n\t\t\tthis.setState({ServerStatusText: \"SERVER OFFLINE\"})\n\t\t\tthis.setState({ WakeOnLanAvailable: false })\n\t\t\tconsole.log(\n\t\t\t\t`Socket is closed. Attempt to reconnect in ${Math.min(\n\t\t\t\t\t10000 / 1000,\n\t\t\t\t\t(that.timeout + that.timeout) / 1000\n\t\t\t\t)} second.`,\n\t\t\t\te.reason\n\t\t\t)\n\n\t\t\tthat.timeout = that.timeout + that.timeout //increment retry interval\n\t\t\tconnectInterval = setTimeout(this.check, Math.min(10000, that.timeout)) //call check function after timeout\n\t\t}\n\n\t\t// websocket onerror event listener\n\t\tws.onerror = (err) => {\n\t\t\tconsole.error('Socket encountered error: ', err.message, 'Closing socket')\n\n\t\t\tws.close()\n\t\t}\n\t}\n\n\tcheck = () => {\n\t\tconst { ws } = this.state\n\t\tif (!ws || ws.readyState === WebSocket.CLOSED) this.connect() //check if websocket instance is closed, if so call `connect` function.\n\t}\n\n\twol = () => {\n\t\tconst { ws } = this.state\n\t\tws.send('WOL')\n\t\t//this.sendSnackBar('WOL request sent !')\n\t}\n\n\tsendSnackBar = (message) => {\n\t\tsetTimeout(() => {\n\t\t\tthis.setState({ SnackBarOn: false })\n\t\t}, 3000)\n\t\tthis.setState({ SnackBarOn: true, SnackBarText: message })\n\t}\n\n\trender() {\n\t\tif (this.state.WakeOnLanAvailable === true) {\n\t\t\treturn (\n\t\t\t\t<div>\n\t\t\t\t\t<h1>{this.state.ServerStatusText}</h1>\n\t\t\t\t\t<button onClick={this.wol}>Wake On Lan</button>\n\t\t\t\t\t{this.state.SnackBarOn === true ? (\n\t\t\t\t\t\t<SnackBar text={this.state.SnackBarText} />\n\t\t\t\t\t) : (\n\t\t\t\t\t\t''\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t)\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}